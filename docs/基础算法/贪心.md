---
title: 贪心
titleTemplate: 基础算法
---

### 调和级数

```cpp
for(int i=1;i<=n;++i)
{
    for(int j=i;j<=n;j+=i)
    {
        //嘿嘿
    }
}
```

这份代码的时间复杂度是多少？

看上去像是$O(n^2)$

别急，分析一下

原式子=$\sum_{i=1}^n\frac{n}{i}=n\sum_{i=1}^n\frac{1}{i}$

用积分近似$\int_{1}^\infty\frac{1}{x}dx=lnx+c$

所以式子时间复杂度是$O(nlogn)$

调和级数是发散的：


$$
T=1+[\frac{1}{2}]+[\frac{1}{3}+\frac{1}{4}]+…\\
\geq 1+\frac{1}{2}+2*\frac{1}{4}+4*\frac{1}{8}+…\\
=O(logn)
$$
### 贪心

两瓶一样的可乐，一瓶两块，一瓶三块，你买哪瓶。

选择买两块的就学会贪心了。

#### 普通贪心：

$n$个物品，价值各不相同，选$m$个物品的最大价值之和是多少？

解答：选最大的$m$个。

#### 排序贪心：

$n$个人接水，第$i$个人需要$t_i$分钟，怎么安排队伍，让所有人等待的时长之和最小？

假设相邻的两个人，接水时间是$t_a$和$t_b$，并且$t_a>t_b$。

这两个人前面有$x$个人，后面有$y$个人。

那么这两个人以及后面的人需要等的总时间是$t_a*(y+2)+t_b*(y+1)$

假如这两个人交换一下位置，总时间变成了$t_a*(y+1)+t_b*(y+2)$

明显变小了，所以应该交换一下。

综上：应该把按时间从小到大排序。



看一个难一点的，国王游戏：

[//]: # (![image-20230628173152865]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230628173152865.png&#41;)

这个明示是要排队，所以考虑排序贪心，假设位置$i$左手的数字是$a_i$，右手是$b_i$，有相邻的两个位置$i,i+1$，假如前面所有人左手上的乘积是$x$，那么$i$在前的贡献是：
$$
max\{\frac{x}{b_i},\frac{x*a_i}{b_{i+1}}\}
$$


$i+1$在前的贡献是：
$$
max\{\frac{x}{b_{i+1}},\frac{x*a_{i+1}}{b_i}\}
$$


如果是$i$在前面比较好，那么应该满足
$$
max\{\frac{x}{b_i},\frac{x*a_i}{b_{i+1}}\}<max\{\frac{x}{b_{i+1}},\frac{x*a_{i+1}}{b_i}\}
$$
因为$\frac{x}{b_{i+1}}$一定要小于$\frac{x*a_{i}}{b_{i+1}}$，所以后面的最大值只可能是$\frac{x*a_{i+1}}{b_i}$，它一定大于$\frac{x}{b_i}$，那么只要让它大于$\frac{x*a_i}{b_{i+1}}$

就是
$$
\frac{x*a_i}{b_{i+1}}<\frac{x*a_{i+1}}{b_i}\\
a_ib_i<a_{i+1}b_{i+1}
$$
综上，把大臣们按$a_i*b_i$从小到大排序就好。

#### 不会更差贪心：

线段选取：

$n$个线段，最多能选出几个互不相交的线段？

考虑以某个顺序选取线段：

我们按从左到右的顺序选，那么最需要考虑选取的线段对之后的影响最小。

那么只要每次都选取能选择的线段中，右端点最靠左的线段。

比如有两个线段$[l1,r1]$和$[l2,r2]$，因为是从左往右选，所以左端点在哪里无所谓，只要不和左边的线段冲突就行，而右端点要尽可能靠左，不然会更多地影响右边的选择，所以选右端点最靠左的线段。

实现上：线段按右端点从小到大排个序，能选就选即可。

```cpp
//按右端点从小到大排序
int pre=0,sum=0;
for(int i=1;i<=n;++i)
{
    if(a[i].l<pre)
    {
        pre=a[i].r;
        ++sum;
    }
}
cout<<sum<<'\n';
```

砍树：

在一个数轴的$n$个不同位置上有$n$棵树，每棵树都可以砍倒，砍倒后它会往左或往右倒下（不碰到其他树），最多砍几棵树？

我们还是从左往右考虑：

如果一棵树可以往左倒，那么一定会倒，因为对右边没影响。

如果可以往右倒，也一定会倒，为什么：

我们只考虑一种情况，就是因为这棵树往右倒了而导致下一颗树不能向左倒下的情况（其他情况显而易见）：

前一棵树倒下，后一棵树有可能向倒，贡献>=1

前一棵树不倒，后一棵树有可能向倒，贡献<=1

所以，前者直接向右倒，至少不会让答案变得更差，还有可能变得更好，就可以直接选择倒。

### 贪心中常用的工具：

$STL$数据结构——堆

一种数据结构，粗略来看，可以视作一个集合，每次可以把里面最大的/最小的数字拿出来。

$\sum_{i=0}^k\frac{x^i}{i!}$

$C++$里面有很方便的工具：

```cpp
priority_queue<int> q;//定义一个堆，名字叫q
for(int i=1;i<=n;++i)
{
    int x;cin>>x;
    q.push(x);//把n个数字放进堆里
}
int y=q.top();//取出堆里面最大的数
q.pop();//把最大的数删掉。
```

如果想取最小的数呢？

```cpp
priori_queue<int,vector<int>,greater<int> > q;//小根堆
```

这样，上面的操作中取出的就是最小的数。

### 练习题

[P1223 排队接水  ](https://www.luogu.com.cn/problem/P1223)

[P1803 凌乱的yyy / 线段覆盖  ](https://www.luogu.com.cn/problem/P1803)

[Woodcutters  ](https://www.luogu.com.cn/problem/CF545C)

[P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G  ](https://www.luogu.com.cn/problem/P1090)