---
title: 排序
titleTemplate: 基础算法
---

## 排序

### 选择排序

基本思想：每次都把最大的数字放在最后一个，就可以把最后一个剔除出排序序列。

这样就等价于把剩下的$n-1$个数字去排序，变成一个规模更小的子问题了！

怎么找到最大的？直接扫一遍

```cpp
for(int i=n;i>=1;--i)
{
    int num=0;
    for(int j=1;j<=i;++j)
    {
        num=max(num,a[j]);
    }
    a[i]=num;
}
```

### 冒泡排序

基本思想和选择排序一致。

但是实现方法有所不同：

从前到后扫一遍，如果前面的比后面的大，就交换相邻的两个数字

```cpp
for(int i=1;i<=n;++i)
{
    for(int j=1;j<n;++j)
    {
        if(a[j]>a[j+1]) swap(a[j],a[j-1]);
    }
}
```

为什么叫冒泡？因为是相邻两个交换，如同从下往上冒泡，如果大泡泡在小泡泡下面，就冒到上面去，最后最大的泡泡在最上面。

但是和选择排序思想基本一致，为什么还要讲这种算法呢？

因为这个和逆序对有关系！

逆序对的定义：

对于一个数列$A$，如果存在两个不同的位置$i,j$，其中$i<j$且$a_i>a_j$，那么$(i,j)$凑成一对逆序对。

如：$5\ 2\ 3\ 1\ 4$

中的逆序对有$(5,2),(5,3),(5,1),(5,4),(3,1)$这$6$对。

冒泡排序和他有什么关系呢？

首先，冒泡排序只有在$a_j>a_{j+1}$的时候才交换，这两个数字一定构成逆序对。

那么，对于$1\sim j-1$位置上的数字，他们和$j\sim n$之间的数字的逆序对数不变。

对于$j+2\sim n$位置上的数字，他们和$1\sim j+1$之间的数字的逆序对数也不变。

综上：一次交换只会让**逆序对数量减一**

总交换次数是序列的逆序对数。

### 快速排序

上面的排序都是$O(n^2)$的，大致思想都是一个一个的剔除出排序队列。

而快速排序思想不同：

首先，我们在序列中随机选一个数字，比如说是第一个数字。

然后，我们将这个数字放在它**该在的位置上**

（*）然后把小于他的数字都放他左边（不排序），大于他的数字都放在它右边（不排序）。

先不管这个怎么实现，先分析时间复杂度：

根据随机原则，我们可以假设这个数字的**期望**大小位于序列的中间位置。

所以会把序列分成两个差不多长的子序列。那么分$logn$次，序列的长度就会变为$1$。

那么我们整个算法，会分成$logn$层，每层的**总长度**都是$n$，假设我们每层一共要花$O(n)$的时间，算法的总复杂度就是$O(nlogn)$

注意，这里是每层的**总长度**是$n$，不是每个函数的长度是$n$。

比如第一层，范围是$1\sim n$，然后我们选择的数字在第$7$个位置上。

那么第二层，就会分成$1\sim 6$和$8\sim n$，在第二层，不是每个处理区间长度都是$n$。

所以每个处理区间，时间复杂度应该和**本区间的长度**相关，而不能是和$n$相关！

然后我们再来说怎么实现前面（*）的内容

```cpp
void solve(int l,int r)
{
    if(l>=r) return;
    int num=a[l],i=l,j=r;
    while(i<j)
    {
        while((i<j)&&a[j]>=num) --j;
        if(i!=j) a[i]=a[j];
        while((i<j)&&a[j]<=num) ++i;
        if(i!=j) a[j]=a[i];
    }
    a[i]=num;
    solve(l,i-1);solve(i+1,r);
}
```

解释一下：$num$是随机选出来的数字，$i,j$是两个下标变量。

先找到最靠右的小于$num$的位置，让原本$a[i]$的位置（除了第一次以外，都是原本大于$num$的位置）变成$a[j]$，即：

```cpp
while((i<j)&&a[j]>=num) --j;
if(i!=j) a[i]=a[j];
```

然后找到最靠左的大于$num$的位置，让原本$a[j]$的位置（原本那个小于$num$的位置）变成$a[i]$，即：

```cpp
while((i<j)&&a[j]<=num) ++i;
if(i!=j) a[j]=a[i];
```

举个例子：

$3\ 6\ 1\ 5\ 2\ 7$取$3$作为$num$，$i=1,j=6$

先让$j$找右边第一个小于$num$的，找到了$j=5(a_j=2)$的位置，让$a_i=a_j$，变成

$2\ 6\ 1\ 5\ 2\ 7$

然后让$i$找左边第一个大于$num$的，找到了$i=2(a_i=6)$的位置，让$a_j=a_i$，变成

$2\ 6\ 1\ 5\ 6\ 7$

让$j$去找，找到了$j=3(a_j=2)$，让$a_i=a_j$，变成

$2\ 1\ 1\ 5\ 6\ 7$

此时$i$找不到了，和$j$会和后结束，此时$i=j=3$

然后让$a_i=num$得到

$2\ 1\ 3\ 5\ 6\ 7$。

此时$3$在它该在的位置上，左边都比$3$小，右边都比$3$大。

可以看出，这个算法时间复杂度是$O(区间长度)$的。所以整体的期望复杂度是$O(nlogn)$

这里是期望复杂度，因为不能保证我们选取的$num$最后一定在正中间，所以只是***期望复杂度***！！！

这是原理。

我们平时怎么写？这么写：

```cpp
int a[101];
sort(a+1,a+n+1);
```

库函数，按从小到大将$a[1]\sim a[n]$排序。

哈哈，不用自己写，这个函数复杂度就是$O(nlogn)$的排序，它是严格的$O(nlogn)$

如果你不想从小到大呢？

```cpp
bool cmp(int a,int b)
{
    return a>b;
}
sort(a+1,a+n+1,cmp);
```

在$sort$后面跟一个$cmp$函数，类型是布尔类型，表示真或假，当$a>b$的时候返回真，这样就会按照从大到小来排序啦~

注意！不要写成$a\geq b$，千万不能带**等于**

因为如果这个比较的正反都成立，就会出错，比如两个数字$a_1=5,a_2=5$比较，如果写的是$a\geq
b$，那么，不管$a_1,a_2$哪个在前，这个比较都将成立，成立就会进行交换，导致这两个数字在不停地交换，算法死循环。

也可以用来排序其他东西，比如

```cpp
struct node
{
    int x,y;
};
bool cmp(node a,node b)
{
    if(a.x==b.x) return a.y<b.y;
    return a.x<b.x;
}
node a[101];
sort(a+1,a+n+1,cmp);
```

### 归并排序

考虑这样一个问题，将两个已经有序的长度为$n$的数列合并起来，变成一个大的有序的数列，需要什么时间复杂度？

是$O(n)$

用两个下标，每次把最小的那个放入新的数组里：

```cpp
int a[101],b[101],c[201];
//假设序列a长度为n，序列b长度为m
int t1=1,t2=1;
for(int i=1;i<=n+m;++i)
{
    if(t1<=n&&(t2>m||a[t1]<b[t2])) c[i]=a[t1++];
    else c[i]=b[t2++];
}
```

那么，如果我们把整个序列分成两个小序列，把这两个序列排好序，然后再按上面方法拼接起来，岂不是完成了排序！

那怎么把两个小序列排好序呢？

简单，接着划分！不停地划分，分到序列长度为$1$为止（就不用排序了）。

然后再不停地按上述方法合并回去，直到把所有序列都合并完。

每次划分都会让序列长度减半，所以划分$logn$次长度就变成$1$了。

每次合并时间都是$O(序列长度)$，每一层的总长度是$O(n)$的。

总时间复杂度是$O(nlogn)$，这次是严格的。

代码如下：

```cpp
void solve(int l,int r)
{
    if(l==r) return;
    solve(l,mid);
    solve(mid+1,r);
    int tl=l,tr=mid+1;
    for(int i=l;i<=r;++i)
    {
        if(tl<=mid&&(tr>r||a[tl]<a[tr]))
        {
            f[i]=a[tl++];
        }
        else f[i]=a[tr++];
    }
    for(int i=l;i<=r;++i) a[i]=f[i];
}
```

而且这样还可以做到一个事情：顺便把逆序对数求出来。

怎么做呢？

我们看合并这一段。

假如我们进入了$else$，是不是说明这里应该放的是右半段序列。

那么左半段序列中，还没有放的数字都应该比这个数字大（如果数字互不相同的话）。

那么直接把左半段中还没有放的数字个数都加起来，得到的就是总的逆序对数了。

有人可能会疑惑：这样能不重复不遗漏地算出所有的逆序对吗？

是可以的，这是分治算法的基本思想：

这是一个长度为$8$的序列的分治结构：

![](https://s2.loli.net/2023/06/28/UNiua8De1ozbmIH.png)

对于一个分治结构来说，每一对逆序对，都可以对应分治上的一个结点（除了最下面一排单独的）。

![](https://s2.loli.net/2023/06/28/lO7R82b9PFwkoQs.png)

因为每个分治结点，都对应一条中位线，对于一对逆序对，我们只要看它跨过了哪些中位线，取最靠上的那个。

比如逆序对$(a_2,a_4)$，那么它既跨过了$(3,4)$，也跨过了$(2,3)$，取最靠上的就是$(2,3)$，而这一对刚好会在$[1,2]$和$[3,4]
$合并为$[1,4]$的时候被统计到。

再比如逆序对$(a_2,a_7)$，它刚好会在$[1,4]$和$[5,8]$合并为$[1,8]$的时候被统计到。

所以，所有的逆序对都刚好被统计一次！这样就可以$O(nlogn)$求出逆序对。

### 练习题

[P1177 【模板】排序  ](https://www.luogu.com.cn/problem/P1177)

[P1271 【深基9.例1】选举学生会  ](https://www.luogu.com.cn/problem/P1271)

[P1093 [NOIP2007 普及组] 奖学金  ](https://www.luogu.com.cn/problem/P1093)

[P1012 [NOIP1998 提高组] 拼数  ](https://www.luogu.com.cn/problem/P1012)

[P1908 逆序对  ](https://www.luogu.com.cn/problem/P1908)



















