---
title: 差分前缀和
titleTemplate: 基础算法
---

### 前缀和

给定一个序列，长度为$n$，$m$次询问，求某一段区间的和。

一个一个加，复杂度$O(nm)$

有没有办法加速！（通通加速）

设数列是$a[1]\sim a[n]$，我们求另一个数列$s[1]\sim s[n]$

其中，$s[i]=a[1]+a[2]+…a[i]$

这个数列很好求出来$s[i]=s[i-1]+a[i]$

当我们求$a[l]\sim a[r]$的和的时候，只需要$s[r]-s[l-1]$

这样，预处理和单次查询复杂度是$O(n)-O(1)$

[//]: # (![image-20230630164724413]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230630164724413.png&#41;)

如图，$a[2]\sim a[4]$的和只要让$s[4]-s[1]$就能得到。

该算法不支持在询问途中对原数列进行任何修改！

### 差分

前缀和的逆操作

设有序列$a[1]\sim a[n]$，求另一个序列$b[1]\sim b[n]$

其中，$b[i]=a[i]-a[i-1]$

这样，$a[i]=b[1]+b[2]+…+b[i]$。

也就是说，差分是前缀和的**逆操作**

形式化地表示，我们设$\sum a$表示序列$a$的前缀和序列，$\Delta a$表示序列$a$的差分序列，那么有
$$
\Delta(\sum(a))=\sum(\Delta(a))=a
$$

比如，我现在要将$a[l]\sim a[r]$全部$+k$，一个一个加是$O(n)$

如果用差分，我们可以在$b[l]+k$，在$b[r+1]-k$。

然后再前缀和回去，可以发现，在$l$以及之后的位置，因为都要加上$b[l]$，所以这部分位置的值都加了$k$。

在$r$之后的位置，因为都要加上$b[r+1]$，所以又把之前加上的$k$减掉了，相当于没变。

这样我们就实现了$a[l]\sim a[r]$全部加$k$。

如果是多次询问，那每次询问只要$O(1)$的时间

预处理和单次查询的时间复杂度是$O(n)-O(1)$

该算法不支持在询问途中对原数列进行任何查询，只能最后再查询！

### 高维前缀和

如果我的数组不是一维的，阁下又将如何应对？

比如是二维的，那么我们有二维原数组$a[i][j]$

那么对应的，有前缀和数组$s[i][j]=\sum_{t1=1}^i\sum_{t2=1}^ja[t1][t2]$

也可以通过递推得到：

```cpp
s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
```

[//]: # (![image-20230630172253661]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230630172253661.png&#41;)

黑色部分面积等于紫色加绿色再减去蓝色+右下角（$a[i][j]$）。

如果我们要求左上角是$(x_1,y_1)$，右下角是$(x_2,y_2)$部分的面积

```cpp
ans=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
```

[//]: # (![image-20230630172700879]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230630172700879.png&#41;)

红色面积等于紫色减去蓝色减去绿色减去棕色。

这样对二维来说还可以，但是维度再增高之后就会出现弊端：

这个前缀和数组的算法，其实我们是在对多个维度进行容斥原理：

```cpp
s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
```

把只有一个维度降低的部分加上，把两个维度都降低的部分减去。

如果升到$k$维，那么我们预处理一个位置就要花$O(2^k)$的时间

采用另一种方法，一维一维的进行前缀和：

```cpp
for(int j=1;j<=m;++j)
    for(int i=1;i<=n;++i) s[i][j]=s[i-1][j]+a[i][j];
for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j) s[i][j]=s[i][j-1]+s[i][j];
```

第一个求和是把第一维做前缀和，即$s[i][j]=a[1][j]+a[2][j]+…+a[i][j]$

第二次求和再把第二维做前缀和。

这样平均每个位置花费的时间就是$O(k)$

对于查询，没啥好办法，嘻嘻。高维一般不查询。

### （*）高阶差分

之前说了一个$a[l]\sim a[r]$都加$k$的方法。

有没有让$a[l]\sim a[r]$分别加$1,2,3,…,r-l+1$的方法。

有的，我们只要求$c=\Delta(b=\Delta(a))$，（$b$是$a$的差分，$c$是$b$的差分）

然后给$c[l]+1,c[r+1]-r$。

那么$b[l]\sim b[r]$就会都加一

那么$a[l]$就会$+1$，$a[l+1]$因为被加了两次，会$+2$，就会产生$a[l]\sim a[r]$实现$+1,+2,+3,…+r-l+1$的效果。

差分三次，四次，更多次会不会神秘效果呢？等你发掘！

### 练习题

[P8218 【深进1.例1】求区间和  ](https://www.luogu.com.cn/problem/P8218)

[P2367 语文成绩  ](https://www.luogu.com.cn/problem/P2367)

[T271585 【模板】二维前缀和  ](https://www.luogu.com.cn/problem/T271585)

[P3397 地毯  ](https://www.luogu.com.cn/problem/P3397)

[P1115 最大子段和  ](https://www.luogu.com.cn/problem/P1115)