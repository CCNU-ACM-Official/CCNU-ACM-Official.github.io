---
title: 递归递推
titleTemplate: 基础算法
---

### 函数

同一种功能在代码里实现很多次很麻烦，可以写一个函数封装起来。

比如三个数比较大小，要交换三次，每次都展开写就很麻烦

写一个swap(x,y)的函数就精简很多。

```cpp
void swap(int x,int y)// 函数（返回值）类型 函数名（参数1，参数2） 
{
	int t=x;x=y;y=x;
}
int main()
{
    int a,b;cin>>a>>b;
    swap(a,b);
    cout<<a<<' '<<b<<endl;
}
```

然后这个函数交换失败了。

因为这样是传值过去了，把主函数里的变量a,b复制了一份，然后送到函数swap里面，主函数里的(a,b)没发生任何变化（数字生命罢了）

应该这样写：

```cpp
void swap(int &x,int &y)// 函数（返回值）类型 函数名（参数1，参数2） 
{
	int t=x;x=y;y=x;
}
int main()
{
    int a,b;cin>>a>>b;
    swap(a,b);
    cout<<a<<' '<<b<<endl;
}
```

这样就是把主函数里的(a,b)本身送到swap函数里面了，swap里面的x和主函数里的a是同一个东西，改了一个另一个也会跟着变。

### 递归

C++中，函数里面可以嵌套调用函数：

```cpp
int fun1()
{
    return 1;
}
int fun2()
{
    return fun1()+2;
}
int main()
{
    cout<<fun2()<<endl;
}
```

也可以在函数里调用自己，但是一定要有结束的情况：

```cpp
int fac(int x)
{
    if(x==1) return 1;
    else return x*fac(x-1);
}
int main()
{
    cout<<fac(3)<<endl;
}
```

如上面这个函数，效果是输出
$$
fac(3)=3*fac(2)=3*2*fac(1)=3*2*1
$$
比如斐波那契数列：

$f_n=f_{n-1}+f_{n-2}$

可以写成：

```cpp
int fib(int n)
{
	if(n<=2) return 1;
    return fib(n-1)+fib(n-2);
}
int main()
{
    int n;cin>>n;
    cout<<fib(n)<<endl;
}
```

### 时间复杂度

但是这个程序会跑多少次呢？

我们引入时间复杂度的概念和大$O$计数法

大$O$计数法就是，不考虑常数因子，只看算法随着数据规模的增长的影响

比如下面这个程序：

```cpp
int x=0,y=1;
for(int i=1;i<=n;++i)
{
	x+=i;
    y*=i;
}
```

它的时间复杂度是$O(n)$，它是$n$次循环，虽然一次循环里面有$2$个操作，但是忽略一个不变的小常数2，记作$O(n)$

```cpp
for(int i=1;i<=n;++i)
{
    for(int j=1;j<=n;++j)
    {
        for(int k=1;k<=50;++k)
        {
            //哈哈
        }
    }
    
    for(int j=1;j<=m;++j)
    {
        //嘿嘿
    }
    
}
```

这份代码的时间复杂度是$O(n*(n*50+m))$

这个$50$也是常数，为什么不忽略呢？因为还挺大的。

```cpp
for(int i=1;i<=n;++i)
{
    int x=i;
    while(x) x/=2;
    //log_2(x)
}
```

这份代码的时间复杂度是$O(nlogn)$，其中$log$的底数通常忽略不写，因为是几都差不多。

回到那个斐波那契

```cpp
int fib(int n)
{
	if(n<=2) return 1;
    return fib(n-1)+fib(n-2);
}
int main()
{
    int n;cin>>n;
    cout<<fib(n)<<endl;
}
```

它的时间复杂度是什么：

每个函数分为两个分支，所以是$O(2^n)$

我们评测机通常一秒能跑$5e7$左右，也就是说，如果$n=1e6$，那么$O(nlogn)$时间复杂度的方法是极限，如果是$O(n^2)$的将会超时。

斐波那契有没有快速一点的方法？有的：
$$
fib(5)=fib(4)+fib(3)\\
=(fib(3)+fib(2))+(fib(2)+fib(1))\\
=((fib(2)+fib(1))+1)+(1+1)
$$
看，虽然分了很多次，但其实实际上访问到的fib(x)中x的值不多，我们可以用数组记录fib(x)的值是多少，下次再访问到直接返回数组的值：

```cpp
int f[110];
int fib(int n)
{
    if(f[n]!=0) return f[n];
    if(n<=2) return 1;
    f[n]=fib(n-1)+fib(n-2);
    return f[n];
}
```

这样的话，每个位置实际上只花了$O(1)$的时间，一共也就只有$1\sim n$这么多位置，所以时间复杂度变成$O(n)$

### 递推

也可以换个方式，直接用数组

一开始知道$f[1]=f[2]=1$

由小的去推大的：

$f[i]=f[i-1]+f[i-2]$

```cpp
for(int i=3;i<=n;++i) f[i]=f[i-1]+f[i-2]
```

台阶问题：

有$n$级台阶，一步可以跨一级或两级，有多少种不同的方法迈到第$n$级台阶？

我们设：$f[n]$表示迈到第$n$级台阶，有多少种不同的方法。

考虑最后一步跨了几级台阶：

如果只跨了一级，那么还需要迈$n-1$级

如果跨了两级，那么还需要迈$n-2$级

所以：

$f[n]=f[n-1]+f[n-2]$

边界：$f[0]=f[1]=1$

### 输出保留两位小数

```cpp
double ans=5;
cout<<fixed<<setprecision(2)<<ans<<endl;
```

### 数据范围

$int$ 表示范围：$-2^{31}\sim 2^{31}-1$

$long long$表示范围：$-2^{63}\sim 2^{63}-1$

在多数题目里面要用到$long long$数据范围。

### 练习题

[P5735 【深基7.例1】距离函数  ](https://www.luogu.com.cn/problem/P5735)

[P1720 月落乌啼算钱（斐波那契数列）  ](https://www.luogu.com.cn/problem/P1720)

[P1464 Function  ](https://www.luogu.com.cn/problem/P1464)

[P1990 覆盖墙壁  ](https://www.luogu.com.cn/problem/P1990)

[P1498 南蛮图腾  ](https://www.luogu.com.cn/problem/P1498)