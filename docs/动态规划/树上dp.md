---
title: 树上dp
titleTemplate: 动态规划
---

### 一些定义

树是一种数据结构（虽然我不这么认为），它表示$n$个点，$n-1$条边的连通图，任意两个点之间有且仅有一条路径。

有的树有根（钦定的深度最小的节点），有的树无根（即没有钦定深度最小的节点）。

对于一个有根树中，根没有父亲和祖先，其他节点的相邻节点中，来自根方向的那个叫父节点（它叫自己父节点的子节点），父节点的父节点（的父节点的父节点的父节点……）叫祖先节点。

对于任意节点，如果断开和父节点之间的边（并删除父节点方向的所有节点），那么这一片叫做这个节点的子树。

最近公共祖先：对于某两个节点来说，这棵树上深度最深的，并且同时是两个节点的祖先的节点，叫做最近公共祖先。

怎么存一棵树呢

推荐用动态数组来存边

```cpp
vector<vector<int> > eg(n+1);//开n+1个vector<int>
for(int i=1;i<=m;++i)
{
    int x,y;
    cin>>x>>y;//x y之间有一条边
    eg[x].emplace_back(y);
    eg[y].emplace_back(x);//如果是无向边就两个方向都写，如果只是x到y就只写第一个。
}
dfs(1,0);

void dfs(int now,int fa)//遍历这棵树，第一个数表示现在是哪个节点，第二个数表示父亲节点是哪个节点
{
    for(int t:eg[now])//按顺序访问eg[now]这个vector 里的元素
    {
        if(t==fa) continue;//如果是从这个方向来的，就跳过。
        dfs(t,now);//访问
    }
}
```

树上天然就有问题的子结构，即以一个点为根的子树的答案由自己所有的子节点转移过来。这样问题形式没变，规模变小了。

### 树形DP

如果一个问题在序列上太简单了，就把它放到树上          ~~《noip命题组官方指南》~~

比如第一节的选位置问题，不能选相邻的两个问题，我们把它放到树上，不能同时选父节点和子节点。最大值可以是多少？

我们设$dp[now][0/1]$表示，以$now$为根的子树中，节点$now$选或者不选时，答案的最大值。

如果这个节点不选，那么子节点可选可不选

$dp[now][0]=\sum_{t} max(dp[t][0],dp[t][1])$

如果这个节点选，那么子节点不能选

$dp[now][1]=(\sum_t dp[t][0])+a[now]$

复杂度是$O(n+m)$的，每个点只访问一次，每条边只访问一次。

但是在树上$m=n-1$，所以复杂度是$O(n)$

```cpp
void dfs(int now,int fa)
{
	for(int t:eg[now])
	{
		if(t==fa) continue;
		dfs(t,now);
		dp[now][0]+=max(dp[t][0],dp[t][1]);//now节点不选
		dp[now][1]+=dp[t][0];//now节点选
	}
    dp[now][1]+=a[now];
}
```

### 树上背包

树上有$n$个节点，每个节点有价值$v_i$，一个节点如果要选，必须要选它的父节点，最多选$k$个节点，求可能的最大价值。

设$dp[now][j]$表示以$now$为根的子树中，选择了$j$个节点的最大价值。

那么就枚举子节点已经选了多少门课

```cpp
void dfs(int now,int fa)
{
    for(int t:eg[now])
    {
        if(t==fa) continue;
        dfs(t,now);
        for(int i=0;i<=k;++i)//一共选了多少门课
        {
            for(int j=0;j<=i;++j)//这个子树里面选了多少门课
            {
                dp[now][i]=max(dp[now][i],dp[now][i-j]+dp[t][j]);
            }
        }
    }
    for(int i=k;i>=1;--i) dp[now][i]=dp[now][i-1]+a[now];//要选子节点必须选根节点。
}
```

这样复杂度是什么样呢？

看上去，每个节点要访问一次，每次更新要花$O(k^2)$，所以总复杂度是$O(nk^2)$。

实际上，复杂度就是$O(nk^2)$，嘻嘻。

但是别急，有优化空间。

第一个循环是$0\sim k$，但是万一遍历到的根本没有$k$个节点呢？那不是浪费了，改进一下！

第二个循环是$0\sim i$，但是万一这个子树里面根本没有$i$个节点呢？那不是浪费了，改进一下！

改进之后：

```cpp
void dfs(int now,int fa)
{
    str[now]=0;//这颗子树里有多少个节点
    for(int t:eg[now])
    {
        if(t==fa) continue;
        dfs(t,now);
        str[now]+=str[t];
        for(int i=0;i<=str[now];++i)//一共选了多少门课
        {
            for(int j=0;j<=str[t];++j)//这个子树里面选了多少门课
            {
                dp[now][i]=max(dp[now][i],dp[now][i-j]+dp[t][j]);
            }
        }
    }
    for(int i=k;i>=1;--i) dp[now][i]=dp[now][i-1]+a[now];//要选子节点必须选根节点。
}
```

这样就改进了，改进完之后，它的复杂度是什么样的呢？

其实就变成了$O(n^2)$

因为现在，任意两个节点，只会在最近公共祖先处被合并一次。如果不是最近公共祖先，那么来自同一个子树的节点是不会互相合并的，所以复杂度是$O(n^2)$



















