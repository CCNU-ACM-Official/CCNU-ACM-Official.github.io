---
title: 最近公共祖先
titleTemplate: 图论
---

### 最近公共祖先

对于一颗树，假如树根是$rt$，对于任意两个节点$x,y$，满足$z$是$x$和$y$的共同祖先，且$z$的最深最大，则称$z$为$x,y$的最近公共祖先（$LCA$）。

如果$x$是$y$的祖先，则$x$是$x,y$的最近公共祖先。

[//]: # (![image-20230722150841262]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230722150841262.png&#41;)

#### 暴力求解

先将两个节点上升到同一高度，如上图，如果$dep[y]>dep[x]$，那么就将$y$不断向父亲爬升，直到两个节点位于同一高度。

然后两个节点同时向上走，直到两个节点走到同一个位置。这个位置就是最近公共祖先。

但是这样求时间复杂度$O(n)$

#### 倍增

预处理数组$f[x][i]$表示$x$的$2^i$级祖先是谁。

同时预处理$dep[x]$表示$x$的深度是多少（$x$距离$rt$的距离是多少）

不妨假设$dep[x]>dep[y]$

假设初始时，$x,y$的深度差$k$，那么利用倍增求$x$的$k$级祖先。

```cpp
if(dep[x]<dep[y]) swap(x,y);
int k=dep[x]-dep[y];
for(int i=20;i>=0;--i) ((k>>i)&1)
{
	x=f[x][i];
}
```

两个节点同时向上跳这段怎么加速捏

观察到这里其实有二分的性质：

如果现在最近公共祖先和这两个节点的距离是$k$，那么$>=k$级祖先都将是同一个节点，而$<k$级祖先都是不同的节点。

但是根据倍增的性质，其实这里不用二分。

我们从大到小枚举第二维$i$：如果$f[x][i]$和$f[y][i]$是同一个点，那么就跳过$i$，而因为$1\leq 2^0+2^1+…+2^{i-1}<2^i$，跳过$i$之后还可以到达$1\sim 2^i-1$范围内的任何一个高度。

```cpp
if(x==y) return;
for(int i=20;i>=0;--i)
{
	if(f[x][i]==f[y][i]) continue;
	x=f[x][i],y=f[y][i];
}
//此时再往上爬一个位置，两个点就重合了
return f[x][0];
```

倍增法求$LCA$单次查询是$O(logn)$的，也是最常用的。

还有一些别的方法，比如树链剖分、$tarjan$、欧拉序+$RMQ$等，这次不介绍了。

### 树上前缀和

一般前缀和/差分操作都在序列上，但是有了$LCA$就可以放在树上了。

假设我们要求树上$x$到$y$路上所有点的权值之和。

设$sum[x]$是$x\sim rt$的权值之和。

那么$sum(x,y)=sum[x]+sum[y]-2*sum[lca]+val[lca]$。

[//]: # (![image-20230722154707658]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230722154707658.png&#41;)

即紫色的线+红色的线减去两倍绿色的线，再加上一个$val[lca]$

### 树上差分

如果要给$(x,y)$这条路径上所有的点都$+k$，那么就给$val[x]+k,val[y]+k$。

然后$val[lca]-k,val[f[val]]-k$。

在最后做一遍**子树和**。

注意这里不是到根的前缀和。

如果反过来，在$lca$处$+k$的话，不能保证这个$+k$不会给到$lca$的其他儿子处，而因为一个点只有一个父亲，所以在$x$处$+k$，在$lca$处消除影响。