---
title: 最短路
titleTemplate: 图论
---

### 最短路

给定一张图，求两个点之间的一条路径，路径总长度最短。

设起点为$st$，终点为$ed$。

#### BFS

如果所有边的长度都是$1$（例如网格图），直接$BFS$。

#### bellman-ford

原理：设置一个数组$dis[N]$，$dis[i]$表示从起点到节点$i$的最短距离是多少。

初始$dis[st]=0$，其他$dis[i]=inf$。

进行$n$次更新，每次更新枚举每一条边，假设这条边是$(x,y,w)$，则令$dis[y]=min(dis[x]+w)$来**松弛**节点$y$的最短距离。

每次更新因为要枚举所有边，所以复杂度是$O(m)$。

最短路最多经过$n-1$条边，所以最多只用$n-1$次更新，总复杂度是$O(nm)$。

```cpp
for(int k=1;k<=n;++k)
{
	for(int x=1;x<=n;++x)
	{
		for(auto [t,v]:eg[x])
		{
			dis[t]=min(dis[t],dis[x]+v);
		}
	}
}
```

#### spfa

上述算法有很大的优化空间：比如第一次更新时，实际上只有$st$节点能去松弛别人，第二次更新时，只有$st$周围的节点能去松弛别人，但是每次都把所有点所有边枚举一遍太浪费了。

从这个角度入手优化，我们把刚才被更新过的点加入队列中，然后每次从队列的首部取一个点出来再去更新别人。

因为如果一个点没被更新过，那它再去更新别人是多余的。

```
bool vis[N];//vis[i]=1时，表示节点i已经在队列里了。
queue<int> q;
q.push(st);
while(!q.empty())
{
	int now=q.front();
	q.pop();
	vis[now]=0;//now这个点被从队列中取出来了
	for(auto [t,v]:eg[now])
	{
		if(dis[t]>dis[now]+v)
		{
			dis[t]=dis[now]+v;
			//这个点被更新了，它可以去更新别人
			q.push(t);
			vis[t]=1;//t节点已经被放入队列里了，防止一个点被放进队列很多次。
			//因为我们是在拿dis[t]更新别的点，dis[t]是个全局变量，所以t只在队列里出现一次就够了。
		}
	}
}
```

这样优化完，在随机数据下，**期望**复杂度是$O(nlogn)$，但最坏情况下仍然是$O(nm)$，如果能用$dij$就不要写$spfa$。

#### Dijkstra

前提：所有边权非负。

在这个前提下，我们考虑动态规划。

一开始，只有$dis[st]=0$，其他都是$inf$。

然后每次都拿出还没有被取过的，$dis$值最小的点去松弛其他点。

为什么这样是对的？

加入现在有三个点还没有被取过：$x,y,z$，它们的$dis$值大小是$dis[x]<dis[y]<dis[z]$。

那么$dis[x]$一定就是最终的答案了。

因为边权都是非负数，不可能再通过其他点加若干条边来到达$x$，且路径长度比$dis[x]$更小。

每次取$dis$最小的点可以用小根堆。

```cpp
typedef array<int,2> pr;
priority_queue<pr,vector<pr>,greater<pr> > q;
void dij()
{
	for(int i=1;i<=n;++i) dis[i]=inf;
	dis[st]=0;q.push(pr{dis[st],st});//dis放前面，节点编号放后面，因为小根堆按前面作为第一关键字排序，第一关键字应该是距离。
	while(!q.empty())
	{
		int now=q.top()[1];
		q.pop();
		if(vis[now]) continue;//如果now已经被取出来过了,注意这里vis用法和spfa不同。
		vis[now]=1;
		for(auto [t,v]:eg[now])
		{
			if(dis[t]>dis[now]+v)
			{
				dis[t]=dis[now]+v;
                //这个不管有没有放进去过，都要再放一次，因为是小根堆，要按照放进去的距离排序，距离被更新了应该再放进去一次。
                //spfa那个不管先拿哪个出来都一样。
				q.push(pr{dis[t],t});
			}
		}
	}
}
```

这个算法每条边被遍历一次，每条边最多对应一次入堆，每个点一次出堆，复杂度是$O(mlogn)$

如果有负边权就不能用$dij$，因为这个算法的原理就是错误的了。

假如我们现在有$x,y,z$，满足$dis[x]<dis[y]<dis[z]$。

然后拿$dis[x]$去更新别人，把$vis[x]=1$，再也不拿$x$出来了。

这时候来了条负边使得$dis[y]+v<dis[x]$，把$dis[x]$给更新了，但是$x$再也不会拿出来了，就导致出错了。

所以就负边就用$spfa$。

#### 负环

有负边可以有最短路，但是如果图中出现了负环就没有最短路了。

因为我可以走到负环上去，然后在环上一直转，最后长度无限小。

$spfa$可以判断图中有没有负环：在算最短路的同时加一个数组，表示到每个点的最短路经过了多少条边，如果超过了$n-1$条边，说明在绕圈，那就说明图中有负环。

#### floyd

定义数组$f[k][i][j]$，表示只允许中途经过$1\sim k$的情况下，$i$到$j$之间的最短距离是多少。

所以$f[n][x][y]$就是$x$到$y$的最短路径。

初始边权设为$f[0][x][y]$。

则有$f[k][x][y]=min(f[k-1][x][y],f[k-1][x][k]+f[k-1][k][y])$

$min$里面第一个情况是不经过$k$，第二个情况是要经过$k$。

这里从$k$点松弛的时候$f[k-1][x][k]$是可以中途经过$1\sim k-1$的情况下，$x$到$k$的最小值。

如果$x$和$k$之间有大于$k$的点怎么办？

比如$1$到$2$的最短路是$1->4->3->5->2$

$k=1$时有$f[1][4],f[4][3],f[3][5],f[5][2]$

$k=2$时有$f[1][4],f[4][3],f[3][5],f[5][2]$

$k=3$时有$f[1][4],f[4][5],f[5][2]$

$k=4$时有$f[1][5],f[5][2]$

$k=5$时有$f[1][2]$。

其实这里面在状态里$k$这一维可以忽略不写。

因为就算把状态写成$f[k][x][y]=min(f[k-1][x][y],f[k][x][k]+f[k][k][y])$，其中$f[k][x][k]\leq f[k-1][x][k]$，所以没有影响，可以直接把第一维去掉。

有点类似区间$dp$的感觉，每次选择编号最小的点，然后把经过这个点的最短路径都合并起来，这要求这个点所连接的路径都是最优子结构，所以按编号顺序$DP$。

```cpp
for(int k=1;k<=n;++k)//这个循环一定要放在最外面，因为是dp
{
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
		}
	}
}
```

这个写法是$O(n^3)$的，不是很优秀，因为就用$dij$可以在$O(nlogn)$时间内算出一个点到其他所有点的最短路，用每个点都当一次起点，也只需要$O(n^2logn)$，所以$floyd$一般是用来模拟边的传递性来实现一些特殊的功能（还有一个优点就是好写。），或者用来限制只能在哪几个点中转，总之这个算法的价值不在单纯的求最短路上。



























