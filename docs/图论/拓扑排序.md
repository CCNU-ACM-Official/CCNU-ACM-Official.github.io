---
title: 拓扑排序
titleTemplate: 图论
---

### 有向无环图

如果一张图上的边都是有方向的，而且这张图上不存在环，即任意一点不能通过图上的有向边走回自己，那么称这张图是有向无环图（$DAG$）

有向无环图可以进行拓扑排序：

#### 拓扑排序

对于一张有向无环图，用队列按如下方向对点进行标号：

先将所有没有入边的点加入队列。

然后开始遍历队列，每取出一个点，给它标号，并将这个点的所有出边删除。

如果删除过后，某个点不存在入边，则将这个点也加入队列。

```cpp
for(int i=1;i<=m;++i)//m条边
{
    int x,y;cin>>x>>y;
    ++rd[y];//y多一条入边(入度)
    eg[x].emplace_back(y);
}
queue<int> q;
for(int i=1;i<=n;++i)
{
    if(rd[i]==0) q.push(i);
}
while(!q.empty())
{
    int now=q.front();
    q.pop();
    for(int t:eg[now])
    {
        --rd[t];//删除这条边
        if(rd[t]==0) q.push(t);
    }
}
```

这个排序有什么价值呢？

如果将动态规划的状态看作点，转移方程看作一个状态到另一个状态的有向边，那么这张图一定是一个有向无环图，否则动态规划将有后效性。

所以，如果一张图是有向无环图，那么这上面一定可以进行动态规划。

比如我们要求最长边：

```cpp
for(int i=1;i<=m;++i)//m条边
{
    int x,y,w;cin>>x>>y>>w;//边长为w
    ++rd[y];//y多一条入边(入度)
    eg[x].emplace_back(pr{y,w});
}
queue<int> q;
for(int i=1;i<=n;++i)
{
    dp[i]=0;
    if(rd[i]==0) q.push(i);
}
while(!q.empty())
{
    int now=q.front();
    q.pop();
    for(auto [t,v]:eg[now])
    {
        --rd[t];//删除这条边
        dp[t]=max(dp[t],dp[now]+v);//动态规划
        if(rd[t]==0) q.push(t);
    }
}
```

所以有向无环图上天然可以动态规划。

怎么判断一个图是不是有向无环图？

直接拓扑排序，如果所有点都被遍历到了，就说明是有向无环图。

如果图上有环，那么环上的点一定不能被环外的点把入度删成$0$。