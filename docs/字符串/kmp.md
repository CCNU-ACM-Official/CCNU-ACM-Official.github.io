---
title: kmp
titleTemplate: 字符串
---

### KMP

注意：本文中字符串以$1$作为起始下标。

判断一个字符串$s$里面所有和$t$相等的子串

暴力：

```cpp
for(int i=1;i<=n;++i)
{
	bool flag=1;
	for(int j=1;j<=m;++j)
	{
		if(s[i+j]!=t[j])
		{
			flag=0;break;
		}
	}
    if(flag) cout<<i<<endl;
}
```

这样是$O(nm)$的。

（当然你可以用哈希做到$O(n)$）

这样匹配其实浪费了很多已知信息。

比如$s=ababa$，$b=aba$

当$i=1$时

```cpp
ababa
aba
```

前三个字符以及匹配上了。

然后第二次是

```cpp
ababa
 aba
```

其实这个没意义，因为直接在第一项就被pass了

第三次

```cpp
ababa
  aba
```

观察在第一次匹配的时候，我们发现$t[1]=t[3]$且$t[3]$和$s[3]$匹配成功了，那么下一步直接去匹配$t[2]$和$s[4]$就可以了。

再看一个例子：

```cpp
abcababc
abcab
```

那么我们匹配完第一个位置，下一步应该是去匹配$t[3]$和$s[6]$。

因为$t[1,2]=t[4,5]$，且$t[4,5]=s[4,5]$。

所以当第一次匹配完之后，可以直接默认$t[1]=s[4],t[2]=s[5]$，然后去匹配$t[3]$和$s[6]$

这样等于是以$s[4]$作为匹配起点了，那为什么$s[2]\sim s[3]$不会作为起点呢。

因为$t[1,3]\neq t[3,5]$这说明，就算以$s[3]$作为匹配起点，它在匹配$t[3]$和$s[5]$的时候（或者是更之前的位置）也一定会失配，所以可以直接跳过。

总结一下上述步骤：

对$t$串中每个位置$i$，求一个前缀函数$nxt[i]$，其含义是$t[1,nxt[i]]=t[i-nxt[i]+1,i]$，且$nxt[i]$是满足要求的最大值。（$nxt[i]<i$）

然后从$s[1]$和$t[1]$开始进行匹配，如果匹配成功，就匹配下一个字符。

如果匹配失败，假如$s$进行到$s[i]$，$t$进行到$t[j]$，在这个位置上匹配失败了（$s[i]\neq t[j]$），则令$i=i+j$，然后$j=nxt[j]+1$。

```cpp
int j=1;
for(int i=1;i<=n;++i)
{
	while(j>1&&s[i]!=t[j]) j=nxt[j-1]+1;
	//如果匹配失败了，那么说明刚才只匹配到j-1,让t[nxt[j-1]]接替t[j-1]匹配上的字符，然后去匹配t[nxt[j-1]+1]和s[i]
    if(s[i]==t[j])
    {
        if(j==m)//匹配完成
        {
            cout<<i-m+1<<'\n';//匹配起点
            j=nxt[j]+1;//和上面一样
        }
        else ++j;//否则，匹配成功一位
    }
    //这里不用管else 因为如果失败，根据上面的循环，说明j=1，下一次还是要从这里匹配
}
```

这样匹配的时间复杂度是$O(n)$的，可以看到每次至少$i$会加一，至于里面那个while，只有每次$+1$的时候才有可能$++j$，而每次至少会让$j-1$，所以里面$while$的次数一共是$O(n)$次。

然后介绍怎么快速求得$nxt$数组

首先定义$nxt[1]=0$

然后令$i=1,j=2$令$t[i]$和$t[j]$进行匹配

如果匹配成功，$nxt[i]=j$。

如果不成功，令$j=nxt[j-1]+1$。

```cpp
int j=1;
for(int i=2;i<=m;++i)
{
	while(j>1&&t[i]!=t[j]) j=nxt[j-1]+1;//匹配失败，则刚刚只匹配到j-1
	if(t[i]==t[j]) nxt[i]=j++;//匹配成功
}
```

这个复杂度也是$O(n)$，分析方法和上面类似。

注意这里的$O(n)$是均摊复杂度，也就是说，并不是每一步都是$O(1)$的，有可能某一步花了$\frac{n}{2}$次，然后其他步骤都只花一次，最后的总时间还是$O(n)$

$kmp$不仅一种写法，可以多尝试不同写法，或者把字符串改成从$0$开始去实现，加深理解。

这里顺便一提，对于某一个数字$k$，如果满足$s[1,k]=s[n-k+1,n]$，那么称$s[1,k]$是字符串$s$的一个$border$

### 字符串周期

求字符串$s$的一个最小周期$t$，满足$s$是$t$无限自我拼接形成的一个子串，且$t$的长度最短。

比如$s=abcabcab$

则最小周期是$t=abc$。

$t$无限拼接后形成$abcabcabcabcabc……$

取前$8$位形成$s$。

有结论：$t=s[1,n-nxt[n]+1]$。

先证明这样可以得到字符串$s$的一个周期：

当$nxt[n]\leq \frac{n}{2}$时，把前$n-nxt[n]$个字符复制两份拼起来，取前$n$个字符就得到了$s$。

当$nxt[n]>\frac{n}{2} $时，也就是说$s[1,nxt[n]]$和$s[n-nxt[n]+1,n]$有重合部分，

[//]: # (![image-20230722230749422]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230722230749422.png&#41;)

假设蓝色线段是整个字符串，红色线段是$s[1,nxt[n]]$和$s[n-nxt[n]+1,n]$两段。

那么根据$nxt$的定义，应该满足$(1)=(1'),(2)=(2')$

而$(1')$和$(2)$的重合的一段，所以有$(1)=(1')=(2)=(2')$。

以此传递下去，则有$(1)=(1')=(2)=(2')=(3)=(3')=(4)=(4')$。其中$(4)$和$(4')$只能匹配上前面一小段。

所以$(1)$就是字符串$s$的一个周期。即$s[1,n-nxt[n]+1]$

接下来证明这个周期是最小周期：

如果存在一个更小长度的$|t|$，满足$t$是$s$的周期，那么$t$通过数次拼接，取出前$n$个字符，那么$s[1,n-|t|]$和$s[|t|,n]$应该是完全相等的，也就是说，$n-|t|$应该是字符串的一个$border$，而且比$nxt[n]$还要大，违反了$nxt$的定义。

















