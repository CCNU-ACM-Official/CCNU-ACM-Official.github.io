---
title: 字符串基础及哈希
titleTemplate: 字符串
---

### 字符串基础

定义一个长度为$n$的字符串$s$，下标范围是$1\sim n$的整数。

#### 加法

设有两个字符串$s$，$t$，则$s+t$表示将字符串$t$接在字符串$s$后面形成的字符串。

#### 字符集

字符串中的所有字符的范围。

#### 子串

$s[l..r]$，表示$s$中$l\sim r$这一段字符顺次排列组成的字符串。

#### 子序列

从字符串$s$中取出若干个位置，按照下标顺序顺次拼接成的字符串。

即子序列$s[p_1],s[p_2],…,s[p_k]$要满足$1\leq p_1<p_2<…<p_k\leq n$

#### 前缀与后缀

对于任意$i\in [1,n]$，前缀表示子串$s[1,i]$，后缀表示子串$s[i,n]$

#### 字典序

两个字符串$s,t$，长度分别为$n,m(n\leq m)$按字典序进行比较：

从前往后进行比较，第一个字符编号（一般是$ACSII$码）较小的字符串字典序小，如果第一个字符相同就比较第二个字符。

如果前$n$个字符都相同，那么长度小的字符串字典序小。

如果长度也相同，那么字典序相同。

根据定义，空串的字典序小于所有非空串。

#### 回文串

对于任意$i\in [1,n]$，$s[i]=s[n-i+1]$的字符串。

#### STL

对于用$char$数组存储的字符串，假如字符串长度为$n$，至少定义为$s[n+1]$。

因为字符串后还跟一个$\0$字符，表示字符串的结尾，所以实际上有$n+1$个位置。

用$len=strlen(s)$来获得字符串长度

如果用$string$存储字符，则不用考虑$\0$的位置。

用$len=s.length()$来获得字符串长度。

直接输入的字符串，占据的位置是$s[0]\sim s[n-1]$。

对于$string$类型，还可以表示为$s.begin()\sim s.end()-1$。字符串的$\0$在位置$s.end()$，所以不用单独考虑$\0$的位置。

### 字符串哈希

哈希其实不是字符串专属，哈希表示的设计一种双射方式将两种不同的事物联系起来。

比如可以认为离散化是一种哈希，我们将$[1,10,100]$映射成$[1,2,3]$，可以看作将原数组做了一个哈希。

字符串哈希是为了将一个字符串映射到一个整数，方便进行各种操作，比如我们直到比较两个字符串要花$O(len)$的时间，而比较两个整数只要花$O(1)$的时间。

#### 哈希

对于一个字符串$S$，字符集是$a\sim z$，那么我们可以将这个字符串看作是一个$26$进制的大整数，其中$a\sim z$分别代表$0\sim 25$。

然而这样有明显的弊端：$aab$和$b$岂不是都代表了$1$。

所以我们把进制$base$取的略大一点，然后将$a\sim z$尽可能不用$0$进行代表（可以用$1\sim 26$或者是$25\sim 50$之类的）。

然后将这个$base$进制整数通过进制转化变成十进制数，就可以把它映射到整数了。

然而这样粗暴的转化问题很大：首先是字符串通常很长，这样转换后数字很大，要高精度，还不如直接用字符串表示呢。

所以我们将这个$26$进制的整数加上一个模数，将它映射到一个大整数然后对某一个数取模，这样映射到的值域范围就可以缩小到$[0,mod-1]$了。

**注意**：本文中的哈希定义都是通过$\sum s[i]*base^{n-i}\ \%mod$定义的，即左侧是高位。

这样映射之后有两条性质：

$1.$在哈希值不一样的时候，两个字符串一定不一样

$2.$在哈希值一样的时候，两个字符串不一定一样

对于第二条，比如一个字符串的哈希值是$75$，另一个是$175$，而对$100$取模后它们都是$75$，这种情况称为哈希碰撞（哈希冲突）。

我们来计算一下哈希碰撞的情况：

假设有两个字符串$s,t$，长度分别为$n,m(n\leq m)$如果这两个字符串发生了哈希冲突，将字符串$s$的末尾与$t$对齐，前面用进制下的$0$填充，则
$$
(\sum_{i=1}^m(s[i]-t[i])*base^{m-i})\ \%mod\ ==0
$$
这里东西可以视为一个关于$base$的$m-1$阶的多项式。

我们就是希望这个多项式等于$0$的概率尽可能减少。

显然$base$不能取到$mod$的因数，不然直接把映射的值域范围缩小$\frac{mod}{base}$倍。

其实在随机情况下，$mod$取值无所谓，只要够大，冲突概率就会比较下。

然而在实际上，有些情况会导致映射出的数列并不是随机的，而是一种等差的分布，比如$mod$的某个因子是$p$，而刚好映射出了大量相差为$p$的数字，这些数字就会分布在$[0,\frac{mod}{p}]$的范围里，加大冲突概率。

为了防止这种情况，一般选取大质数作为$mod$，比如$998244353,1e9+7,1e9+9$等等。

为了防止哈希冲突，还可以选用两套$base$和$mod$来对同一个字符串进行两次哈希，如果两次哈希的值均一致才认为原字符串一致，只要有一个不同就认为两个字符串不同。

对字符串进行哈希：

```cpp
for(int i=1;i<=n;++i)
{
	hs=hs*base+(s[i]-'a'+1);
    hs%=mod;
}
```

#### 子串

因为字符串哈希实质上是一个$base$进制的大数字，$s$被表示为
$$
s[1]*base^{n-1}+s[2]*base^{n-2}+…+s[n]*base^0
$$
如果想得到$s[l]\sim s[r]$这个子串的哈希值，可以通过对进制进行操作

我们把$hs$改成一个数组来得到：

```cpp
for(int i=1;i<=n;++i)
{
	h[i]=h[i-1]*base+(s[i]-'a'+1);
	h[i]%=mod;
}
```

此时

$h[r]=s[1]*base^{r-1}+s[2]*base^{r-2}+…+s[r]$

$h[l-1]=s[1]*base^{l-1-1}+s[2]*base^{l-1-2}+…+s[l-1]$

为了去掉$1\sim l-1$这一段，我们把$h[l]*base^{r-l+1}$

那么$hash(s[l]\sim s[r])=h[r]-h[l-1]*base^{r-l+1}$

```cpp
int getsub(int l,int r)
{
	//pw[k]=base^k
	return (h[r]-h[l-1]*pw[r-l+1]%mod+mod)%mod
}
```

#### 拼接

如果要把字符串$s$和$t$拼起来，也可以用类似进制的方法。

设字符串$s$长度为$n$，$t$长度为$m$。

则$hash(s+t)=hash(s)*base^m+hash(t)$

最基础的哈希用法就是判断某两个字符串是否相等。

————————————第一天到此为止—————————————————————————————————————

#### 应用

$1.$字符串匹配

对于长度为$n$的字符串$s$和长度为$m$的字符串$t$。

不妨设$n\geq m$。

枚举$s$的所有长度为$m$的子串，判断哈希值是否与$t$相同。

$O(n)$

$2.$允许$k$个位置不同的字符串匹配

还是$s,t$，假设现在枚举到的$s$的子串是$s'$。

从头部开始，二分+哈希找到第一个$s'$与$t$不同的位置。

如果能在$k+1$次二分中完成整个匹配，则满足条件。

$O(nklogn)$

$3.$最长回文子串

求$s$中的一个最长的子串，满足这个子串是回文串。

先对$s$进行哈希，取两个值，一个是正序的哈希，另一个是倒序的哈希。

二分这个回文子串的最长长度是多少。

注意，这里奇数长度和偶数长度要分开二分，不能一起算。

假设当前二分的长度是$len$。

枚举$s$所有长度为$len$的子串，用判断正序哈希和倒序哈希是否相同。

$4.$最长公共子串。

两个字符串$s,t$，长度为$n,m$，求最长的在两个字符串中都出现过的子串。

仍然二分这个子串的长度$len$。

枚举$s$所有长度为$len$的子串，将它们的哈希值记录在$map$里。

然后再枚举$t$所有长度为$len$的子串，判断该哈希值是否在$map$中出现过。

#### 例题

[P2757 [国家集训队] 等差子序列  ](https://www.luogu.com.cn/problem/P2757)

非常经典的哈希例题

简述：给定一个$1\sim n$的排列，问是否存在：
$$
1\leq p_1<p_2<p_3<…<p_k\leq n(k\geq 3)
$$
满足$a_{p_1},a_{p_2},…,a_{p_k}$是等差子序列。

回答$Y$或者$N$。

既然它要求至少为$3$，那其实就找一个长度为$3$的就行了。

从前往后枚举$a_i$，去寻找是否存在一个数字$k$，满足$a_i-k$在前面出现，$a_i+k$在后面出现。（$k$可以为负数）。

我们搞一个数组，如果数字$i$出现过，则$b_i=1$，否则$b_i=0$。

当枚举到$a_i$的时候，应该至少有一个$k$，满足$b[a_i-k]=1,b[a_i+k]=0$。

如果都不存在，那么说明在$b$数组上，以$a_i$为中心的所有子串都是回文串。

所以可以把$b$数组建成$a$的正序和倒序哈希数组，判断$b[a_i]$为中心的子串是不是回文串。

这个哈希数组是变化的，每次枚举完$i$就要把$b[a_i]$的位置变成$1$。

所以可以用线段树来维护这两个哈希数组，区间合并刚好可以用上面讲到的哈希拼接。