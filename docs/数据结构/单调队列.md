---
title: 单调队列
titleTemplate: 数据结构
---

### 单调队列

[滑动窗口](https://www.luogu.com.cn/problem/P1886)

有一个长度为$n$的序列$A$，求所有长度为$k$的子区间里的最大值和最小值。

先介绍最大值怎么算，最小值差不多道理。

如果一个区间一个区间的求，复杂度应该是$O(nk)$的，不好。

观察第一个区间$[1,k]$和第二个区间$[2,k+1]$之间有很多共同点，可以重复利用，考虑怎么利用。

我们设置一个队列，这个队列很厉害，它不是一个先进先出的，它是双端队列，队列的头部和尾部都可以插入和删除元素。

然后我们按顺序，把前$k$个数字插入队列

```cpp
int head=1,tail=0;//一开始head=1,tail=0,保证tail-head+1=0，表示队列里元素为空
for(int i=1;i<=k;++i)
{
	q[++tail]=i;
}
```

但是我们其实发现，有些数字不需要被插入进去，没什么意义。

比如$5\ 2\ 3$。我们先把$5$插入进去，然后把$2$插入进去，然后再把$3$插入进去。

然后发现，这个$2$比$3$位置靠前，对后面区间的影响不如$3$影响得多。

数字大小还比$3$小，那不是铁废物吗，所以直接把$2$丢出去

（如果一个人比你小，还比你强，那你可以remake了）。

所以改成

```cpp
int head=1,tail=0;//一开始head=1,tail=0,保证tail-head+1=0，表示队列里元素为空
for(int i=1;i<=k;++i)
{
	while(head<=tail&&a[q[tail]]<=a[i]) --tail;
	//如果队列非空，而且队尾比a[i]小，那么把队尾删除
	q[++tail]=i;
}
```

那么这时候，队列头部的数字就是最大值。

然后考虑完了$[1,k]$这个区间，再去考虑$[2,k+1]$区间。

如果$a[1]$还在队列里，那肯定是队首，所以判断一下队首了行了。

```cpp
int head=1,tail=0;//一开始head=1,tail=0,保证tail-head+1=0，表示队列里元素为空
for(int i=1;i<k;++i)//i<k 先少放一个
{
	while(head<=tail&&a[q[tail]]<=a[i]) --tail;
	//如果队列非空，而且队尾比a[i]小，那么把队尾删除
	q[++tail]=i;
}
for(int i=k;i<=n;++i)
{
    if(head<=tail&&q[head]==i-k) ++head;//如果队首超出长度k，弹出。
    while(head<=tail&&a[q[tail]]<=a[i]) --tail;//如果队尾还没a[i]大，直接弹出。
    q[++tail]=i;
    cout<<a[q[head]]<<' ';//区间[i-k+1,i]的最大值就在队首位置。
}
```

该队列中的数有两个特点：

1.下标单调，因为我们是按下标维度从小到大把数字加入的。

2.数值单调，因为下标已经单调，如果有$i<j$，而$a_i<a_j$的情况（假如数列里是单调递减的），那么我们假如$a_j$的时候，剩下的所有区间里，$a_j$能够提供贡献的机会严格覆盖了$a_i$，而且$a_j$比$a_i$答案更优秀，所以$a_i$没有用，应该被弹出。

如果$a_i>a_j$，虽然$a_i$答案更优秀，但是当右端点移动到$i+k$的时候，$a_i$就不能发挥作用了，而$a_j$还可以，它有可能提供贡献，所以保留。