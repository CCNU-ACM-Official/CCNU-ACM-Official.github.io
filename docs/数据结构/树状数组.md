---
title: 树状数组
titleTemplate: 数据结构
---

### 树状数组

#### 前缀和

继续考虑前缀和，上一节分块提到了，将$\sqrt{n}$个分成一组做到查询修改平衡。

然而我们在修改**一个**位置的时候，其实只花了$O(1)$的时间。

所以其实这个平衡是查询和修改是$O(\sqrt{n})-O(1)$。

还可以再平衡一下。

设$lowbit(i)$表示$i$转化成二进制后，最低位的$1$代表的数字。

比如说：

$lowbit(5)=lowbit((101)_2)=1$

$lowbit(6)=lowbit((110)_2)=2$

$lowbit(12)=lowbit((1100)_2)=4$

然后对于数字$i$，储存从以$i$为结尾，长度为$lowbit(i)$的区间和信息。

引理一：

对于一个数字$i$来说，它最多被$log_2(n)$个区间所包含，包含它的区间只能是$i$不断递归加上$lowbit(i)$得到的数字所包含。

注意，这里的递归加是这个意思：

$2+lowbit(2)=4,4+lowbit(4)=8,……$

证明：

如果数字$x>i$，且$x$不是$i$通过递归加$lowbit(i)$得到的：

如果$lowbit(x)<lowbit(i)$，那么$x$和$i$之间至少差了$lowbit(x)$个数字（因为$i$的后面几位是没有的，只能是通过+1来得到的$lowbit(x)$），所以$x$的区间不包含$i$。

如果$lowbit(x)\geq lowbit(i)$，那么$i$的$lowbit(i)$所在的位比$x$的最低位还低，不断地递归加$lowbit(i)$一定能得到$x$。

```cpp
void update(int x,int k)
{
    for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=k;//将a[x]+k
}
```



引理二：任意$1\leq x\leq n$，区间$[1,x]$的和可以通过$log_2(n)$个区间拼起来得到。

将$x$中二进制的每一位对应的十进制数字加起来，刚好得到$x$。

所以先拿出$[x-lowbit(x)+1,x]$这段区间，然后将$x-=lowbit(x)$，新的得到的数字将刚好包含$x$从小到大第二个二进制位长度的区间，且和第一个区间是连续的，将所有区间加起来。

```cpp
int query(int x)
{
    int sum=0;
	for(int i=x;i>=1;i-=lowbit(i)) sum+=tr[i];
    return sum;
}

```

如果我们要查询$[l,r]$区间的和，就算$[1,r]-[1,l-1]$的和，这一点和前缀和类似。

树状数组其实就是动态的去维护一个前缀和信息，所以继承了前缀和的特点，即维护的信息要有**可逆性**

比如，求一段区间的和是可逆的，用$[1,r]-[1,l-1]$就可以。

求一段区间的最大公约数是不可逆的，即使知道了$[1,r]$的最大公约数和$[1,l-1]$的最大公约数，也不能求出$[l,r]$的最大公约数。

可逆的概念比可减要广泛一点，比如矩阵乘法，我可以快速求一段区间的矩阵乘法的答案，只要存在逆矩阵。

或者在模意义下求一段区间的乘积，只要存在乘法逆元。

#### 差分

再解析一下，树状数组可以动态，在线地做到修改一个数的值，查询$1\sim i$的和。

那么它还可以实现动态差分操作。

差分操作只是修改两个数的值，以及求前缀和组合，所以树状数组完全可以实现。

先构造一个差分数组，把他建立树状数组（其实就是挨个把每个位置都$update$）。

当遇到操作$[l,r]$全部$+k$时，将树状数组上$l$位置$+k$，$r+1$位置$-k$。

当遇到查询某个点的值时，直接在树状数组上求$[1\sim x]$的和。

### 值域树状数组

求逆序对数。

从前往后枚举数字，然后对于每个位置上的数字，去求前面有多少个大于自己的数字，然后再把自己加入集合。

求第$i$个数字前面有多少个大于自己的，如果去枚举位置要花$O(n)$。

可以去枚举值域，如果第$i$个数字是$x$，总数字是$1\sim n$，那么就看前面的数字在$x+1\sim n$范围内有多少个。

这个其实是一个前缀和问题，不过每次都要新加入一个数字。

可以用树状数组或者线段树来表示这个前缀和问题。

```cpp
//树状数组写法
for(int i=1;i<=n;++i)
{
    int x=a[i];
	ans+=(i-1)-query(x);//总数减去[1,x]范围内数字个数
	update(x,1);//x位置+1
}
```

这里的树状数组或者线段树，第x个位置表示，数字大小为$x$的数字有多少个，也就是在值域上建树，每个下标对应一个数值而不是位置。

其实这是一个二维偏序问题。（大概可以理解为一种可以被排序的信息叫一种偏序）

一个维度是下标维度，另一个维度是数值大小。

我们求的是所有的$i<j$且$a_i>a_j$的对数。

如果我们把下标作为横坐标，$a_i$作为纵坐标，那么这个问题还可以看作是，对于二维平面中的每一个点的左上角的点数和。

如果一个问题是多维偏序问题，一般可以对其中一个维度排序，另一个维度用数据结构（或者是归并排序）解决。