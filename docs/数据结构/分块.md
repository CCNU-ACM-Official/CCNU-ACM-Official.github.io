---
title: 分块
titleTemplate: 数据结构
---

### 分块

给定一个长度为$n$的序列，$m$次操作，每次问一段区间的和是多少，或者改某个位置上的数字。

这样就不能前缀和或者差分了，前缀和不能修改，差分不能在修改过程中插入询问。

而前缀和不能修改因为每个位置记录了从自己到第一个的值加起来，这样预处理（修改）-查询的复杂度是$O(n)-O(1)$的。

太不平衡了！

所以考虑我们前缀和少处理一点，不要直接从$a[i]$加到$a[1]$。

对数列进行分块，我们设每$B$个数字分成一块，数列一共分成$\frac{n}{B}$块。

对每一块，算出这一块的数值和是多少。

对于查询操作，复杂度最多是$O(\frac{n}{B}+B)$（在区间范围内，整块的直接起来了，不足一整块的暴力一个一个加。）

对于修改操纵，只要改一下这个位置所在的块的和是多少，复杂度是$O(B)$

总复杂度可以算作$O(m(B+\frac{n}{B}))$

根据基本不等式，$B+\frac{n}{B}\leq 2*\sqrt{B*\frac{n}{B}}=2*\sqrt{n}$，在$B=\frac{n}{B}$时取到最小值，也就是$B=\sqrt{n}$。

所以复杂度是$O(m\sqrt{n})$。

```cpp
int cnt=sqrt(n)+1;//块大小
for(int i=1;i<=n;++i)
{
    b[i]=(i-1)/cnt+1;//第i个数字属于哪一块，i/cnt上取整数。
    sum[b[i]]+=a[i];//求块的和
    if(!bl[b[i]]) bl[b[i]]=i;
    br[b[i]]=i;//第b[i]块的左右端点。
}
```

```cpp
//修改a[x]=y
for(int i=bl[b[x]];i<=br[b[x]];++i) sum[b[x]]+=y-a[x];
a[x]=y;

//查询[l,r]区间。
if(b[l]==b[r])//r-l+1<=B，暴力。
else
{
    int tl=b[l]+1,tr=b[r]-1;
    for(int i=l;i<bl[tl];++i) ans+=a[i];
    for(itn i=br[tr]+1;i<=r;++i) ans+=a[i];//先把两边的散块加上
    for(int i=tl;i<=tr;++i) ans+=sum[i];//整块的一起加。
}

```

显然分块也支持区间修改，按照查询的方式去改就可以了。

分块算法本质上还是根号平衡。

例题：[模板题](https://www.luogu.com.cn/problem/P2801)

### 平衡算法

[弹飞绵羊](https://www.luogu.com.cn/problem/P3203)

有$n$个位置，每个位置有一个弹力装置，第$i$个位置站上去会被弹到$i+a[i]$位置去。

$m$次询问，每次问从$p$出发，弹几次飞出序列，或者修改一个位置的参数。

还是按$\sqrt{n}$分块，每$\sqrt{n}$个位置合为一块

每个块记录信息：从第$i$块的第$j$个位置出发， 经过多少次离开第$i$块，到达哪个位置。

这个每一块的处理其实是$O(B)$的，因为只要在块内从后往前去递推。

```cpp
for(int i=r;i>=l;--i)//第i块范围是$l~r$
{
    if(i+a[i]>r) b[i]=1,c[i]=i+a[i];
    else
    {
        b[i]=b[i+a[i]]+1,c[i]=c[i+a[i]];
    }
}
```

查询的时候，就可以一块一块的跳了。

修改的时候只要改当前所在块里的所有信息了行了，因为每个点只记录到自己块内能飞到哪里。

### 根号分治

[哈希冲突](https://www.luogu.com.cn/problem/P3396)

不用管什么是哈希冲突，直接读题。

给定一个长度为$n$的序列，$m$次操作：

第一种：给两个数字$p,x$，查询所有下标同余于$x\%p$的位置的数字和。

第二种：改变某个位置上数字的值。

如果$p>\sqrt{n}$，那么位置个数不超过$\sqrt{n}$个，直接暴力。

如果$p\leq \sqrt{n}$，那么$p$不超过$\sqrt{n}$种，直接提前$p=1\sim \sqrt{n}$的答案分别是多少。

