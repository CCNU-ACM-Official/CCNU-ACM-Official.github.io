---
title: 线段树
titleTemplate: 数据结构
---

### 线段树

给定一个序列，我们将它不断地二分裂。

[//]: # (![image-20230718231655544]&#40;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230718231655544.png&#41;)

那么它最多分裂$log_2(n)$层，可以使得每一个节点代表的区间长度都是$1$。（上图为序列$1\sim 8$的分裂过程）

假设我们每个节点记录的是这个节点表示的区间的和。

创建一颗线段树：

```cpp
int ans[4*N];//根据下面的结点编号规则，1+2+4+8+……<=2n，但是因为序列长度可能为奇数，导致最下面一排可能单挂几个结点，所以数组应该开到4*n以上。
void build(int l,int r,int p)//结点编号是p,当前区间是[l,r]
{
    if(l==r)
    {
        ans[p]=a[l];//叶子节点，区间长度为1，区间和就是a[l];
        return;
    }
    int mid=(l+r)/2;
    build(l,mid,2*p);//左边子树
    build(mid+1,r,2*p+1);//右边子树
    //除了最下面一排以外，第k层应该刚好有2的k次方个结点（从0开始数）,所以结点p的左子节点编号是2p,右子节点编号是2p+1。
    //根结点编号是1
    ans[p]=ans[2*p]+ans[2*p+1];//这个区间的和等于下面两个区间的和加起来。
}
```



显然在这个结构下，我们修改一个位置的值，只影响它向上的边所经过的结点，一共是$O(logn)$个。

```cpp
void update(int pos,int l,int r,int p,int k)//将pos位置的值改为k，当前结点区间是[l,r]，编号是p
{
    if(l==r)
    {
        ans[p]=k;
        return;
    };
    int mid=(l+r)/2;
    if(pos<=mid) update(pos,l,mid,2*p,k);
    else update(pos,mid+1,r,2*p+1,k);
    ans[p]=ans[2*p]+ans[2*p+1];//子节点改了，自己也要改。
}
```

而算一个区间的贡献，是一些结点拼起来，最大可能是多少个结点？

如果我们查询的区间跨过了当前节点代表的区间的中点，那么就要去左和右子节点分别寻找答案，再合并起来。

这样似乎就不是单纯的$O(logn)$了。

但其实还是。

我们在第一个跨过节点代表的区间的中点的时候（查询区间跨过了mid），会分到左右两边，这样会变成两条向下查询的路径。

我们考虑其中一条的复杂度，然后乘以$2$。

被分开之后，我们查询的区间的某一个边界，一定和当前节点的区间的某个边界重合。

如果之后不再被区间$mid$分开，那么复杂度就是$O(logn)$

如果之后被某个区间的$mid$分开，那么被分开的两个区间里面，有一个区间和子节点代表的区间完全重合，所以只用花$O(1)$的时间，复杂度也是$O(logn)$

```cpp
int query(int tl,int tr,int l,int r,int p)//查询的区间是[tl,tr]，当前节点信息是l,r,p
{
    if(tl<=l&&r<=tr) return ans[p];//如果当前节点被查询区间包括
    int sum=0,mid=(l+r)/2;
    if(tl<=mid) sum+=query(tl,tr,l,mid,2*p);
    if(tr>mid) sum+=query(tl,tr,mid+1,r,2*p+1);
    return sum;
}
```

区间修改：

如果我们要对区间进行修改，那虽然涉及到的区间是$O(logn)$个（和上面查询一样的分析方法），但是每个区间所对应的子区间也应该全部进行修改。

如果每次修改都把设计到的所有区间都改了，那复杂度就变成$O(n)$。

为此，我们设计一个**懒标记**tag。

意思就是，当我们要修改某个区间的所有子区间时，就对这个区间打个标记，而不往子区间进行遍历。

当下一次我们要访问这个区间的子区间时，再把这个修改信息传到两个儿子区间上去，这样向下修改的复杂度就被下次访问的时间所中和了。

而那些不被访问到的地方，就一直打着标记不管他。

```cpp
void pushdown(int l,int r,int p)
{
    int mid=(l+r)/2;
    
    ans[2*p]=(mid-l+1)*tag[p];//下放到左子区间。
    tag[2*p]=tag[p];
    
    ans[2*p+1]=(r-mid)*tag[p];//下放到右子区间
    tag[2*p+1]=tag[p];
    tag[p]=0;//下放之后标记取消。
}
void update(int tl,int tr,int l,int r,int p,int k)//把[tl,tr]赋值为k
{
    if(tl<=l&&r<=tr)
    {
        ans[p]=(r-l+1)*k;
        tag[p]=k;//标记，这个区间的所有子区间都应该变成k
        return;
    }
    if(tag[p]) pushdown(l,r,p);//如果这个区间有标记，把这个标记下放到子区间。
    if(tl<=mid) update(tl,tr,l,mid,2*p,k);
    if(tr>mid) update(tl,tr,mid+1,r,2*p+1,k);
    ans[p]=ans[2*p]+ans[2*p+1];//子节点改了，自己也更新一下。
}
```

注意，如果用了懒标记，那么查询的时候也要记得下放。

可以发现，这里的区间信息不是由前缀和那种减法（求逆）得到的，而是直接由几个小区间的信息合并得到的。

所以它维护的信息不需要可逆，只需要可快速合并。

比如求最大公约数，显然不可逆。

但是求两个数的最大公约数只要$O(logn)$，属于是可快速合并的。

如果你是区间修改，区间查询，那么还需满足：

$1.$信息对信息可（快速）合并。

$2.$信息对标记可合并。

$3.$标记对标记可合并。

但总体来说还是比可逆的泛用性强。