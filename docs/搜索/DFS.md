---
title: BFS
titleTemplate: 搜索
---

## DFS

### 递归枚举

举个例子，将$n$分解成$k$个不同的正整数之和，输出所有方案（数字种类和顺序不同都可以）：

暴力一点的方式是写$k$重循环，枚举每个位置上的数字，但是如果$k$是通过输入给定的，就不可行了。

我们可以先枚举第一个数字是多少，比如是$a[1]$，那么问题就变成了$n-a[1]$分解成$k-1$个不同的正整数之和

变成了一个类似的子问题，可以考虑用递归来实现：

```cpp
int a[1001];//a数组负责存答案
int k;//一共要分解成k个数字
void dfs(int now,int n)//现在是第now个数字，还需要分解数字n
{
    if(now==k+1)//已经有k个数字了
    {
        if(n==0)//分解完成
        {
            for(int i=1;i<=now;++i) cout<<a[i]<<' ';
            cout<<'\n';
        }
        return;
    }
    for(int i=1;i<=n;++i)//这个位置用的数字是多少
    {
        a[now]=i;
        dfs(now+1,n-i);//下一个位置，要分解的数字减小了i，个数减少了一个。
    }
}
```

### 回溯

八皇后问题： 在$n*n$的棋盘上放$n$个棋子，每一行，每一列和每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

从左上到右下的某条对角线上的所有坐标$(i,j)$，满足$i+j=k$是个定值。

从右上到坐下的某条对角线上的所有坐标$(i,j)$，满足$i-j=k$是个定值。

我们问题设计成，在剩下的$n$行里面，放$n$个棋子，这样就不用考虑行的限制了。

但是为了考虑列和对角线的限制，需要开三个辅助数组

```cpp
bool f1[110],f2[110],f3[110];//分别表示列、对角线1，对角线2
int a[110];//存答案，a[i]表示第i行棋子放在第几列
int n;//一共有n行
void dfs(int i)//在第i行
{
    if(i==n+1)
    {
        for(int j=1;j<=n;++j) cout<<a[j]<<' ';
       	cout<<'\n';
        return;
    }
    for(int j=1;j<=n;++j)//枚举放在哪一列
    {
        if(f1[j]==1) continue;//如果这一列被放过了，跳过
        if(f2[i+j]==1) continue;//如果这条对角线1被用过了，跳过
        if(f3[i-j+50]==1) continue;//如果这条对角线2被用过了，跳过，+50是防止变成负数。
        a[i]=j;
        f1[j]=f2[i+j]=f3[i-j+50]=1;//标记
        dfs(i+1);
        //回溯，因为还要去枚举其他的情况，所以刚才做的标记要撤销
        a[i]=0;
        f1[j]=f2[i+j]=f3[i-j+50]=0;//取消标记
    }
}
```

### 减枝

$DFS$就像从一个初始状态出发，每个状态都可以到达若干不同的状态，像一颗开枝散叶的树（其实这个定义并不严格，因为有些状态会到达同一个节点，比如第一个例子中的$n$分解成$k$个数字，前两个数字是$2,2$和$1,3$都会达到$n-4$分解成$k-2$个数字的状态。），所以，我们优化$DFS$的时候，想办法让它少进入一些状态，来减少时间复杂度，把这个过程称为减枝。

#### 记忆化

如例子一中，前两个数选$2,2$和$1,3$都会进入同一个状态，我们称为$sta(n-4,k-2)$，如果我们只计算方案数而不关心每个方案具体长什么样，那么就可以把$sta(n-4,k-2)$的答案给记录下来，第二次进入这个状态的时候直接返回。

因为有可能本来就是$0$种方案，所以我们给没到过的状态标记为$-1$

```cpp
int k;//一共要分解成k个数字
int dp[1010][1010];
int dfs(int now,int n)//现在是第now个数字，还需要分解数字n
{
    if(now==k+1)//已经有k个数字了
    {
        if(n==0) return 1;//分解完成，多了一种方案
        return 0;
    }
    if(dp[now][n]!=-1) return dp[now][n];
    int ans=0;
    for(int i=1;i<=n;++i)//这个位置用的数字是多少
    {
        ans+=dfs(now+1,n-i);//下一个位置，要分解的数字减小了i，个数减少了一个。
        ans%=mod;//如果需要取模的话
    }
    dp[now][n]=ans;
    return dp[now][n];
}
```

#### 可行性剪枝

还是这个例子，在枚举这个位置用的数字是多少的时候，其实不用枚举到$n$，因为现在是第$now$个数字，算上这个数字一共还要放$k-now+1$个数字，那么这几个数字至少是$1$，所以要给他们留出空位，上界应该改成。

```cpp
for(int i=1;n-i<=k-now+1;++i)
{
    ans+=dfs(now+1,n-i);//下一个位置，要分解的数字减小了i，个数减少了一个。
    ans%=mod;//如果需要取模的话
}
```

#### 最优性剪枝

有的搜索题是要求$x$的最小值，那么我们用一个全局变量记录现在已经搜到的最小值是多少，如果现在状态的答案比已经搜到的最小值还大，就直接返回。

```cpp
int ans=inf;
void dfs(int now,int ret)//now是状态参数，ret是这个状态的答案
{
    if(ret>ans) return;//现在的答案比已经搜到的答案还要差，没必要再搜下去了，当然前提是这个ret不会再变小了！！！
    /*
    	继续搜索
    */
}
```

#### 经典例题

[生日蛋糕](https://www.luogu.com.cn/problem/P1731)

## 题目描述

7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 $N\pi$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。

设从下往上数第 $i$（$1 \leq i \leq M$）层蛋糕是半径为 $R_i$，高度为 $H_i$ 的圆柱。当 $i \lt M$ 时，要求 $R_i \gt R_{i+1}$ 且 $H_i \gt H_{i+1}$。

由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。

请编程对给出的 $N$ 和 $M$，找出蛋糕的制作方案（适当的 $R_i$ 和 $H_i$ 的值），使 $S=\dfrac{Q}{\pi}$ 最小。

（除 $Q$ 外，以上所有数据皆为正整数）。

样例输入输出

```
100
2
```

```
68
```

表面积可以表示成最底下一圈的原的面积加上所有层的侧面积，可以先枚举最底下是多大，然后在途中只计算侧面积。

可以直接考虑$DFS(now,v,ret,prer,preh)$表示还剩$now$层（从下往上），体积是$v$，表面积是$ret$，上一层的半径是$prer$，上一层高度是$preh$

```cpp
int ans=1e9;
void dfs(int now,int v,int ret,int prer,preh)
{
    if(now==0)
    {
        if(v==n) ans=min(ans,ret);
        return;
    }
    for(int i=1;i<prer;++i)//要比上一层半径小，所以到pre-1为止。
    {
        for(int j=1;j<preh;++j)
        {
            dfs(now-1,v+j*i*i,ret+2*i*j,i,j);
        }
    }
}
for(int i=1;i<=n;++i)
{
	for(int j=1;j<=n;++j)
	{
		dfs(m-1,i*i*j,i*i+2*i*j,i,j);
	}
}
```

这样肯定会超时啦，想想怎么优化吧~

可行性剪枝：

剩下$now$层的体积至少是$(1^3+2^3+3^3+…+now^3)$，（表面$i*i$，高度$i$），设为$b[now]$如果$v$加上$b[now]$已经大于$n$就返回。

剩下$now$层数字都要互不相同，所以第$now$的半径和高度至少是$now$，所以枚举下届是$now$开始枚举。

假设先枚举半径，再枚举高度，因为要保证后面的层数还能放下蛋糕，所以当半径是$i$时，高度至多是$(n-v-b[now-1])/(i*i)$

最优性剪枝：

如果还剩$now$层，剩下的体积$V=(n-v)$，第$i$层的侧面积为$S_i$。
$$
2*V=\sum_{i=1}^{now}2*r_i*r_i*h_i=\sum_{i=1}^{now}r_i*S_i\leq r_{now}*\sum_{i=1}^{now}S_i\\
\sum_{i=1}^{now}S_i\geq \frac{2V}{r_{now}}
$$
所以剩余的侧面积至少是$\frac{2(n-v)}{prer}$，如果这个数字加上$ret$大于等于已经求出的表面积，则返回。

改变枚举顺序：

如果我们从小到大去枚举半径和高度，那么对体积的削弱较小，后续可选择的方案更多，如果从大到小去枚举，那么后续可选择的方案更少，节点状态数就会变少。同时更容易早一步计算出一个当前的答案，最大化利用最优性剪枝。

```cpp
int ans=1e9;
int n,m;
int b[21];
void dfs(int now,int v,int ret,int prer,int preh)
{
    if(now==0)
    {
        if(v==n) ans=min(ans,ret);
        return;
    }
    if(v+b[now]>n) return;//如果现在的体积加上剩下now层最少需要的体积大于n则返回
    if(ret+2*(n-v)/prer>=ans) return;//如果现在的表面积加上剩余now层最少的表面积大于等于ans则返回
    //从大到小枚举，减少搜索树枝条
    for(int i=prer-1;i>=now;--i)//要比上一层半径小，所以到pre-1为止。
    {
    	int h=min(preh-1,(n-v-b[now-1])/(i*i));//选择半径i的时候高度j的最大值
        for(int j=h;j>=now;--j)
        {
            dfs(now-1,v+j*i*i,ret+2*i*j,i,j);
        }
    }
}
void solve()
{
	cin>>n>>m;
	for(int i=1;i<=20;++i)
	{
		b[i]=b[i-1]+i*i*i;//b[i]是剩下i层最少需要多少体积
	}
	for(int i=n;i>=m;--i)
	{
		int h=(n-b[m-1])/(i*i);
		for(int j=h;j>=m;--j)
		{
			dfs(m-1,i*i*j,i*i+2*i*j,i,j);
		}
	}
	cout<<ans<<'\n';
}
```

### 练习题

[P2404 自然数的拆分问题  ](https://www.luogu.com.cn/problem/P2404)

[P1219 [USACO1.5] 八皇后 Checker Challenge  ](https://www.luogu.com.cn/problem/P1219)

[P1784 数独  ](https://www.luogu.com.cn/problem/P1784)

[P1731 [NOI1999] 生日蛋糕  ](https://www.luogu.com.cn/problem/P1731)

