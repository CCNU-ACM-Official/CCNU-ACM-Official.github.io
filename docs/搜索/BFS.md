---
title: BFS
titleTemplate: 搜索
---

## BFS

深度有限搜索会向着一个方向一直走，走到头为止，再退回去尝试其他路线，而广度优先搜索是在每个方向上都一步一步地走。

$DFS$:（数字标号是访问节点的顺序）

![](https://s2.loli.net/2023/07/04/xFudvyIeMpirVfL.png)

$BFS$:

![](https://s2.loli.net/2023/07/04/TdNyuOoKm36iSFa.png)

$DFS$的好处是方便通过已经得到的答案进行一些优化和剪枝，而$BFS$方便测量某个节点距离初始节点的距离。

例如：

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

从初始点$(x,y)$，先看看走一步能到哪些为止，再从走一步能到达的点出发，看看走两步能到哪些位置，以此类推，就可以知道到每个点最少要花几步。

这里要用到队列，$STL$有关于队列的工具$queue$（当然手写也不是很麻烦）。

队列是一个先入先出表（其实就是模拟排队）。

```cpp
struct node
{
	int x,y;
};
queue<node> q;
q.push(x)//将x加入队列
node now=q.front();//取出队列的首部元素（即队列中最早放进去的那个元素）
q.pop();//将队列的首部元素扔出队列
if(!q.empty());//判断队列是否为空
int sum=q.size();//求队列里元素数量
/*
用数组实现：
node q[100010];
int head=1,tail=0; 初始head=0,tail=1表示队里没有元素，也可以保证元素个数是tail-head+1;
q[++tail]=x;//将x加入队列
node now=q[head];//取出队列的首部元素（即队列中最早放进去的那个元素）
++head//将队列的首部元素扔出队列
if(head<=tail);//判断队列是否为空
int sum=tail-head+1;//求队列里元素数量
*/
```

一开始把起点丢进队列，每次取队列的首部作为起点，我们每走到一个没走到过的位置，就把它丢进队列。

```cpp
int dis[1001][1001];//初始都是inf
q.push((node){x,y});
while(!q.empty())
{
    node now=q.front();
    int x=now.x,y=now.y;
    q.pop();
    for(枚举走一步能到达的位置(tx,ty))
    {
        if(dis[tx][ty]!=inf) continue;
        //如果这个位置已经被走到过了，那么不可能比dis[x][y]+1还远，因为之前枚举到的点的dis不大于dis[x][y]
        dis[tx][ty]=dis[x][y]+1;//更新到这个点的最短距离
        q.push((node){tx,ty});//把(tx,ty)放入队列。
    }
}
```

这样可以做到每个点得到的都是最短距离，因为我们相当于是先得到了所有走一步能到达的位置，然后再从所有走一步能到达的位置出发，到达所有走两步能到达的位置，以此类推，而且根据这个算法，在任意时刻，队列里的点距离起点的距离之差不超过$1$。

假设队列前一半距离是$x$，中间一段距离是$x+1$，最后一段距离是$x+2$，那么我们现在要拿来扩展的点距离是$x$，它扩展到的点距离应该是$x+1$，所以距离$x+2$的点此时不应该出现在队列里。

### 双向搜索

$BFS$和$DFS$中都存在

搜索树的节点个数并不是线性增长的，比如一个节点可以有两个子节点，那么规模为$n$的数据，可能有$2^n$个节点。

如果我们可以每次搜一半的数据，然后将两部分拼起来，那么就会变成$2^{\frac{n}{2}}*2$个节点。效果群拔！

[P4799 [CEOI2015 Day2] 世界冰球锦标赛  ](https://www.luogu.com.cn/problem/P4799)

有$1\leq n\leq 40$个数字，选取任意多个，问有多少种和不超过$M$的方案数？

我们把$40$分成两部分，每部分不超过$20$个，然后把这$20$个所有可能的$2^{20}$种情况的和全部列出来，列成两个数组。

然后问题就变成了，在两个数组长度为$2^{20}$的数组中各选一个数，有多少种情况两个数的和不超过$M$。

那么就将两个数组各自排序后，枚举其中一个数组选什么，在另一个数组里二分。

[P1379 八数码难题  ](https://www.luogu.com.cn/problem/P1379)

$3*3$的棋盘上有$1\sim 8$和一个空位，每次可以把一个数字和空位交换位置，最少多少次交换能变成给定的形态？

我们用$v1[]$和$v2[]$来标记某个状态是否到达过。可以从初始状态和目标状态同时开始$BFS$，将初始状态的标识符设为$1$，目标状态的标识符设为$2$，每当初始状态拓展到一个新位置，把$v1$标记，目标状态拓展到新位置就把$v2$标记，如果一个位置的$v1,v2$都被标记了，就说明会和了，把从两个方向来的步数加起来就可以了。



### 练习题

[P1135 奇怪的电梯  ](https://www.luogu.com.cn/problem/P1135)

[P1605 迷宫  ](https://www.luogu.com.cn/problem/P1605)

[P1596 [USACO10OCT] Lake Counting S  ](https://www.luogu.com.cn/problem/P1596)

[P1443 马的遍历  ](https://www.luogu.com.cn/problem/P1443)

[P4799 [CEOI2015 Day2] 世界冰球锦标赛  ](https://www.luogu.com.cn/problem/P4799)

