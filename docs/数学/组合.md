---
title: 组合
titleTemplate: 数学
---

## 组合

### 定义

$A_n^m$表示从$n$个互不相同的数中选出$m$个，并排成一列的方案数。

第一个位置有$n$种选择，第二个位置有$n-1$种选择……

所以$A_n^m=n*(n-1)*…*(n-m+1)=\frac{n!}{(n-m)!}$

特别的，$A_n^n=n!$，就是全排列的方案数。

$C_n^m$表示从$n$个互不相同的数种选出$m$个的方案数。

我们知道$A_n^m$是选出$n$个并排序的方案数，那么我们把排序的重复情况去掉。

$C_{n}^m=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}$

$C_n^m$也可以写作$\dbinom{n}{m}$。前者是欧式记法，后者是苏联记法。

$C_n^m$的另一个获取方式：考虑第$n$件物品选还是不选，如果第$n$件不选，那么剩下的情况是$C_{n-1}^m$，如果第$n$件选，剩下的情况是$C_{n-1}^{m-1}$

所以$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$

递推：

```cpp
for(int i=0;i<=n;++i)
{
	C[i][0]=1;
	for(int j=1;j<=i;++j)
	{
		C[i][j](=C[i-1][j]+C[i-1][j-1])%mod;
	}
}
```

阶乘：

```cpp
fac[0]=inv[0]=1;//fac[i]是i的阶乘,inv[i]是i的阶乘的逆元
for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
inv[n]=fast(fac[n],mod-2);//费马小定理
for(int i=n-1;i>=1;--i) inv[i]=inv[i+1]*(i+1)%mod;
int C(int n,int m)
{
    if(n<0||m<n) return 0;//不合法
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
```

后面组合数部分都采用苏联记法。

### 二项式定理

$$
(a+b)^n=\dbinom{n}{0}a^n+\dbinom{n}{1}a^{n-1}b+…+\dbinom{n}{n-1}ab^{n-1}+\dbinom{n}{n}b^n\\
=\sum_{k=0}^n\dbinom{n}{k}a^{n-k}b^k
$$



组合意义：$(a+b)^n$其实是$n$个$(a+b)$相乘（废话），那么对于乘积中的$a^{n-k}b^k$这一项，它的系数等价于在$n$个$(a+b)$里面，有$k$个选择了$b$的方案数，本质上等同于$n$个不同的数里面选$k$个的方案数，所以这一项的系数是$\dbinom{n}{k}$

### 隔板法

$n$个相同的苹果分到$m$个相同篮子里，每个篮子里至少有一个苹果，有多少种不同的方案数？

我们把$n$个苹果摆成一排，然后在一排苹果形成的$n-1$个空隙（不算两边）中选$m-1$个位置，插入隔板，会分成$m$部分。每种插入隔板的方式一一对应一个分苹果方式。

所以答案是$\dbinom{n-1}{m-1}$

如果不要求每个篮子至少有一个苹果：那么先加入$m$个苹果，然后再分成$m$份，再给每一份都减去一个苹果，方案数$\dbinom{n+m-1}{m-1}$

将分苹果问题形式化一点，就是，求：
$$
x_1+x_2+…+x_m=n
$$
的方案数。

其他变形：

求
$$
x_1+x_2+…x_m=n
$$
的方案数，但是要满足$a_i\leq x_i\leq b_i$。

那么我们先给每个$x_i$分配一个$a_i$打底，转化成
$$
x_1+x_2+…+x_m=n-\sum_i^ma_i
$$
要求$x_i\leq b_i-a_i$

这个只能用容斥原理慢慢搞。

### 多重集排列

有$k$个物品，第$i$个物品有$n_i$个，一共有$n$个，它的全排列数列是：
$$
\frac{n!}{\prod_{i=1}^kn_i!}=\frac{n!}{n_1!n_2!…n_k!}
$$
组合意义就是$n!$是全排列，然后每个相同元素内部的$n_i!$被除掉。

### 圆排列公式

从$n$个数中选择$m$个数，排成一个环的方案数。

考虑先从$n$个数中选择$m$个数排列的方案数是$\frac{n!}{(n-m)!}$

然而每个排列中的$m$个数字，任何一个当首位得到的环排列都是一样的，所以方案数是$\frac{n!}{(n-m)!m}$

### 一些组合恒等式

1.由定义易得：
$$
\dbinom{n}{m}=\dbinom{n}{n-m}
$$
2.$2^n$是$n$个物品选不不选的所有方案：
$$
\sum_{i=0}^n\dbinom{n}{i}=2^n
$$
3.范德蒙德卷积
$$
\sum_{i=0}^k\dbinom{n}{i}\dbinom{m}{k-i}=\dbinom{n+m}{k}
$$
由组合意义可以讨论得到。

特别地
$$
\sum_{i=0}^n\dbinom{n}{i}=\sum_{i=0}^n\dbinom{n}{i}\dbinom{n}{n-i}=\dbinom{2n}{n}
$$
3.考虑编号最大的数字选了哪个，左边的求和分别对应选择了$n+1\sim k+1$的所有情况。
$$
\sum_{i=k}^n\dbinom{i}{k}=\dbinom{n+1}{k+1}
$$
4.先选$r$个，再从里面选$k$个和先选$k$个，剩下的里面选$r-k$个是一样的。
$$
\dbinom{n}{r}\dbinom{r}{k}=\dbinom{n}{k}\dbinom{n-k}{r-k}
$$

5. 把左边式子加一个$\dbinom{l}{k+1}$，求和符号就可以依次进位变成$\dbinom{r+1}{k+1}$。

$$
\sum_{i=l}^r\dbinom{i}{k}=\dbinom{r+1}{k+1}-\dbinom{l}{k+1}
$$



### 卡特兰数

给$n$个$1$和$n$个$0$，有多少种排列方案，使得数列任意一个前缀，$1$的数量不少于$0$的数量。

排列的总数量是$\dbinom{2n}{n}$（在$2n$个位置里面选$n$个位置放$1$）。

然后考虑所有非法的方案，假设某个位置第一次让这个序列变得非法（即$1$放了$k$个，$0$放了$k+1$个），后面还剩$n-k$个$1$和$n-k-1$个$0$，我们将后面的$0$和$1$的数量交换一下，那么这个序列一共有$n+1$个$0$和$n-1$个$1$。

其实$n+1$个$0$和$n-1$个$1$排成的所有排列和$n$个$1$，$n$个$0$排成的不合法情况是一一对应的

因为$n+1$个$0$和$n-1$个$1$排成的每个排列都一定能找到一个位置，$1$放了$k$个，$0$放了$k+1$个，那把剩下的$0,1$数量交换，就成了$n$个$1$，$n$个$0$的不合法情况。

所以总数量是$\dbinom{2n}{n}-\dbinom{2n}{n-1}$



如果是$n$个$1$，$m$个$0$，然后依然前缀不能比后缀多，那方案数就是$\dbinom{n+m}{n}-\dbinom{n+m}{m-1}$，讨论方法和上面一样。

某个递推式：

我们考虑和第一个$1$配对的$0$在哪。

如果第一个和$1$配对的$0$中间夹了$i$对$10$，那么方案是$Cat_i*Cat_{n-i-1}$

所以有递推式：$Cat_n=\sum_{i=0}^{n-1}Cat_i*Cat_{n-i-1}$

一些常见的卡特兰数情况：

1.括号序列的匹配情况。

2.$50$和$100$的纸币的找零问题。

3.入栈出栈方案数。

4.从$(0,0)$到$(n,n)$，不穿过主对角线的方案数。

常见的转化成递推式讨论情况的卡特兰数情况：

1.$n$个节点可以构造多少种不同的二叉树（讨论左右儿子各多少个节点）。

2.正$n$边形划分数。

### 练习题

[P3197 [HNOI2008] 越狱  ](https://www.luogu.com.cn/problem/P3197)

[P5520 [yLOI2019] 青原樱  ](https://www.luogu.com.cn/problem/P5520)

[NOIP2011 提高组\] 计算系数 ](https://www.luogu.com.cn/problem/P1313)

[P1044 [NOIP2003 普及组] 栈  ](https://www.luogu.com.cn/problem/P1044)







